Repository Structure for app:
===================

├── page.js
├── page_client-reference-manifest.js


File Contents:
=============


FILE: .next\server\app\page.js
==============================
const CHUNK_PUBLIC_PATH = "server/app/page.js";
const runtime = require("../chunks/ssr/[turbopack]_runtime.js");
runtime.loadChunk("server/chunks/ssr/node_modules_next_dist_66bdff._.js");
runtime.loadChunk("server/chunks/ssr/[root of the server]__ea5163._.js");
runtime.loadChunk("server/chunks/ssr/app_db13a2._.js");
runtime.loadChunk("server/chunks/ssr/app_layout_tsx_ab3da7._.js");
runtime.loadChunk("server/chunks/ssr/node_modules_16929d._.js");
runtime.loadChunk("server/chunks/ssr/_756781._.js");
runtime.getOrInstantiateRuntimeModule("[project]/.next-internal/server/app/page/actions.js [app-rsc] (ecmascript)", CHUNK_PUBLIC_PATH);
module.exports = runtime.getOrInstantiateRuntimeModule("[project]/node_modules/next/dist/esm/build/templates/app-page.js?page=/page { METADATA_0 => \"[project]/app/favicon.ico.mjs { IMAGE => \\\"[project]/app/favicon.ico [app-rsc] (static)\\\" } [app-rsc] (structured image object, ecmascript, Next.js server component)\", MODULE_1 => \"[project]/app/layout.tsx [app-rsc] (ecmascript, Next.js server component)\", MODULE_2 => \"[project]/node_modules/next/dist/client/components/not-found-error.js [app-rsc] (ecmascript, Next.js server component)\", MODULE_3 => \"[project]/app/page.tsx [app-rsc] (ecmascript, Next.js server component)\" } [app-rsc] (ecmascript)", CHUNK_PUBLIC_PATH).exports;

FILE: .next\server\app\page_client-reference-manifest.js
========================================================
globalThis.__RSC_MANIFEST = globalThis.__RSC_MANIFEST || {};
globalThis.__RSC_MANIFEST["/page"] = {"moduleLoading":{"prefix":"/_next/","crossOrigin":null},"clientModules":{"[project]/node_modules/next/dist/client/components/error-boundary.js <module evaluation>":{"id":"[project]/node_modules/next/dist/client/components/error-boundary.js [app-client] (ecmascript)","name":"*","chunks":["static/chunks/_2b2515._.js","static/chunks/app_favicon_ico_mjs_5930e7._.js"],"async":false},"[project]/node_modules/next/dist/esm/client/components/layout-router.js <module evaluation>":{"id":"[project]/node_modules/next/dist/client/components/layout-router.js [app-client] (ecmascript)","name":"*","chunks":["static/chunks/_2b2515._.js","static/chunks/app_favicon_ico_mjs_5930e7._.js"],"async":false},"[project]/node_modules/next/dist/esm/client/components/client-page.js":{"id":"[project]/node_modules/next/dist/client/components/client-page.js [app-client] (ecmascript)","name":"*","chunks":["static/chunks/_2b2515._.js","static/chunks/app_favicon_ico_mjs_5930e7._.js"],"async":false},"[project]/node_modules/next/dist/esm/client/components/client-segment.js":{"id":"[project]/node_modules/next/dist/client/components/client-segment.js [app-client] (ecmascript)","name":"*","chunks":["static/chunks/_2b2515._.js","static/chunks/app_favicon_ico_mjs_5930e7._.js"],"async":false},"[project]/node_modules/next/dist/esm/client/components/not-found-boundary.js <module evaluation>":{"id":"[project]/node_modules/next/dist/client/components/not-found-boundary.js [app-client] (ecmascript)","name":"*","chunks":["static/chunks/_2b2515._.js","static/chunks/app_favicon_ico_mjs_5930e7._.js"],"async":false},"[project]/node_modules/next/dist/esm/lib/metadata/metadata-boundary.js <module evaluation>":{"id":"[project]/node_modules/next/dist/lib/metadata/metadata-boundary.js [app-client] (ecmascript)","name":"*","chunks":["static/chunks/_2b2515._.js","static/chunks/app_favicon_ico_mjs_5930e7._.js"],"async":false},"[project]/node_modules/next/dist/esm/lib/metadata/metadata-boundary.js":{"id":"[project]/node_modules/next/dist/lib/metadata/metadata-boundary.js [app-client] (ecmascript)","name":"*","chunks":["static/chunks/_2b2515._.js","static/chunks/app_favicon_ico_mjs_5930e7._.js"],"async":false},"[project]/app/layout.tsx <module evaluation>":{"id":"[project]/app/layout.tsx [app-client] (ecmascript)","name":"*","chunks":["static/chunks/node_modules_90ff86._.js","static/chunks/_60515f._.js","static/chunks/app_layout_tsx_36ac26._.js"],"async":false},"[project]/app/page.tsx <module evaluation>":{"id":"[project]/app/page.tsx [app-client] (ecmascript)","name":"*","chunks":["static/chunks/node_modules_90ff86._.js","static/chunks/_60515f._.js","static/chunks/app_layout_tsx_36ac26._.js","static/chunks/_96ad38._.js","static/chunks/app_page_tsx_19cf49._.js"],"async":false},"[project]/node_modules/next/dist/client/components/error-boundary.js":{"id":"[project]/node_modules/next/dist/client/components/error-boundary.js [app-client] (ecmascript)","name":"*","chunks":["static/chunks/_2b2515._.js","static/chunks/app_favicon_ico_mjs_5930e7._.js"],"async":false},"[project]/node_modules/next/dist/esm/client/components/client-page.js <module evaluation>":{"id":"[project]/node_modules/next/dist/client/components/client-page.js [app-client] (ecmascript)","name":"*","chunks":["static/chunks/_2b2515._.js","static/chunks/app_favicon_ico_mjs_5930e7._.js"],"async":false},"[project]/app/page.tsx":{"id":"[project]/app/page.tsx [app-client] (ecmascript)","name":"*","chunks":["static/chunks/node_modules_90ff86._.js","static/chunks/_60515f._.js","static/chunks/app_layout_tsx_36ac26._.js","static/chunks/_96ad38._.js","static/chunks/app_page_tsx_19cf49._.js"],"async":false},"[project]/node_modules/next/dist/esm/client/components/client-segment.js <module evaluation>":{"id":"[project]/node_modules/next/dist/client/components/client-segment.js [app-client] (ecmascript)","name":"*","chunks":["static/chunks/_2b2515._.js","static/chunks/app_favicon_ico_mjs_5930e7._.js"],"async":false},"[project]/node_modules/next/dist/esm/client/components/render-from-template-context.js":{"id":"[project]/node_modules/next/dist/client/components/render-from-template-context.js [app-client] (ecmascript)","name":"*","chunks":["static/chunks/_2b2515._.js","static/chunks/app_favicon_ico_mjs_5930e7._.js"],"async":false},"[project]/app/layout.tsx":{"id":"[project]/app/layout.tsx [app-client] (ecmascript)","name":"*","chunks":["static/chunks/node_modules_90ff86._.js","static/chunks/_60515f._.js","static/chunks/app_layout_tsx_36ac26._.js"],"async":false},"[project]/node_modules/next/dist/esm/client/components/error-boundary.js":{"id":"[project]/node_modules/next/dist/client/components/error-boundary.js [app-client] (ecmascript)","name":"*","chunks":["static/chunks/_2b2515._.js","static/chunks/app_favicon_ico_mjs_5930e7._.js"],"async":false},"[project]/node_modules/next/dist/esm/client/components/error-boundary.js <module evaluation>":{"id":"[project]/node_modules/next/dist/client/components/error-boundary.js [app-client] (ecmascript)","name":"*","chunks":["static/chunks/_2b2515._.js","static/chunks/app_favicon_ico_mjs_5930e7._.js"],"async":false},"[project]/node_modules/next/dist/esm/client/components/layout-router.js":{"id":"[project]/node_modules/next/dist/client/components/layout-router.js [app-client] (ecmascript)","name":"*","chunks":["static/chunks/_2b2515._.js","static/chunks/app_favicon_ico_mjs_5930e7._.js"],"async":false},"[project]/node_modules/next/dist/esm/client/components/render-from-template-context.js <module evaluation>":{"id":"[project]/node_modules/next/dist/client/components/render-from-template-context.js [app-client] (ecmascript)","name":"*","chunks":["static/chunks/_2b2515._.js","static/chunks/app_favicon_ico_mjs_5930e7._.js"],"async":false},"[project]/node_modules/next/dist/esm/client/components/not-found-boundary.js":{"id":"[project]/node_modules/next/dist/client/components/not-found-boundary.js [app-client] (ecmascript)","name":"*","chunks":["static/chunks/_2b2515._.js","static/chunks/app_favicon_ico_mjs_5930e7._.js"],"async":false}},"ssrModuleMapping":{"[project]/node_modules/next/dist/client/components/error-boundary.js [app-client] (ecmascript)":{"*":{"id":"[project]/node_modules/next/dist/client/components/error-boundary.js [app-ssr] (ecmascript)","name":"*","chunks":["server/chunks/ssr/node_modules_81538d._.js","server/chunks/ssr/[root of the server]__ee9ba9._.js"],"async":false}},"[project]/app/page.tsx [app-client] (ecmascript)":{"*":{"id":"[project]/app/page.tsx [app-ssr] (ecmascript)","name":"*","chunks":["server/chunks/ssr/node_modules_50a59c._.js","server/chunks/ssr/[root of the server]__dc8f92._.js","server/chunks/ssr/app_globals_73c377.css","server/chunks/ssr/_bd8b6a._.js"],"async":false}},"[project]/node_modules/next/dist/client/components/not-found-boundary.js [app-client] (ecmascript)":{"*":{"id":"[project]/node_modules/next/dist/esm/client/components/not-found-boundary.js [app-ssr] (ecmascript)","name":"*","chunks":["server/chunks/ssr/node_modules_81538d._.js","server/chunks/ssr/[root of the server]__ee9ba9._.js"],"async":false}},"[project]/node_modules/next/dist/client/components/layout-router.js [app-client] (ecmascript)":{"*":{"id":"[project]/node_modules/next/dist/esm/client/components/layout-router.js [app-ssr] (ecmascript)","name":"*","chunks":["server/chunks/ssr/node_modules_81538d._.js","server/chunks/ssr/[root of the server]__ee9ba9._.js"],"async":false}},"[project]/node_modules/next/dist/client/components/client-page.js [app-client] (ecmascript)":{"*":{"id":"[project]/node_modules/next/dist/esm/client/components/client-page.js [app-ssr] (ecmascript)","name":"*","chunks":["server/chunks/ssr/node_modules_81538d._.js","server/chunks/ssr/[root of the server]__ee9ba9._.js"],"async":false}},"[project]/app/layout.tsx [app-client] (ecmascript)":{"*":{"id":"[project]/app/layout.tsx [app-ssr] (ecmascript)","name":"*","chunks":["server/chunks/ssr/node_modules_50a59c._.js","server/chunks/ssr/[root of the server]__dc8f92._.js","server/chunks/ssr/app_globals_73c377.css"],"async":false}},"[project]/node_modules/next/dist/lib/metadata/metadata-boundary.js [app-client] (ecmascript)":{"*":{"id":"[project]/node_modules/next/dist/esm/lib/metadata/metadata-boundary.js [app-ssr] (ecmascript)","name":"*","chunks":["server/chunks/ssr/node_modules_81538d._.js","server/chunks/ssr/[root of the server]__ee9ba9._.js"],"async":false}},"[project]/node_modules/next/dist/client/components/render-from-template-context.js [app-client] (ecmascript)":{"*":{"id":"[project]/node_modules/next/dist/esm/client/components/render-from-template-context.js [app-ssr] (ecmascript)","name":"*","chunks":["server/chunks/ssr/node_modules_81538d._.js","server/chunks/ssr/[root of the server]__ee9ba9._.js"],"async":false}},"[project]/node_modules/next/dist/client/components/client-segment.js [app-client] (ecmascript)":{"*":{"id":"[project]/node_modules/next/dist/esm/client/components/client-segment.js [app-ssr] (ecmascript)","name":"*","chunks":["server/chunks/ssr/node_modules_81538d._.js","server/chunks/ssr/[root of the server]__ee9ba9._.js"],"async":false}}},"edgeSSRModuleMapping":{},"rscModuleMapping":{"[project]/node_modules/next/dist/client/components/error-boundary.js [app-client] (ecmascript)":{"*":{"id":"[project]/node_modules/next/dist/client/components/error-boundary.js (client proxy)","name":"*","chunks":["server/app/page.js"],"async":false}},"[project]/node_modules/next/dist/client/components/not-found-boundary.js [app-client] (ecmascript)":{"*":{"id":"[project]/node_modules/next/dist/esm/client/components/not-found-boundary.js (client proxy)","name":"*","chunks":["server/app/page.js"],"async":false}},"[project]/app/page.tsx [app-client] (ecmascript)":{"*":{"id":"[project]/app/page.tsx (client proxy)","name":"*","chunks":["server/app/page.js"],"async":false}},"[project]/node_modules/next/dist/client/components/client-segment.js [app-client] (ecmascript)":{"*":{"id":"[project]/node_modules/next/dist/esm/client/components/client-segment.js (client proxy)","name":"*","chunks":["server/app/page.js"],"async":false}},"[project]/node_modules/next/dist/lib/metadata/metadata-boundary.js [app-client] (ecmascript)":{"*":{"id":"[project]/node_modules/next/dist/esm/lib/metadata/metadata-boundary.js (client proxy)","name":"*","chunks":["server/app/page.js"],"async":false}},"[project]/node_modules/next/dist/client/components/client-page.js [app-client] (ecmascript)":{"*":{"id":"[project]/node_modules/next/dist/esm/client/components/client-page.js (client proxy)","name":"*","chunks":["server/app/page.js"],"async":false}},"[project]/node_modules/next/dist/client/components/layout-router.js [app-client] (ecmascript)":{"*":{"id":"[project]/node_modules/next/dist/esm/client/components/layout-router.js (client proxy)","name":"*","chunks":["server/app/page.js"],"async":false}},"[project]/node_modules/next/dist/client/components/render-from-template-context.js [app-client] (ecmascript)":{"*":{"id":"[project]/node_modules/next/dist/esm/client/components/render-from-template-context.js (client proxy)","name":"*","chunks":["server/app/page.js"],"async":false}},"[project]/app/layout.tsx [app-client] (ecmascript)":{"*":{"id":"[project]/app/layout.tsx (client proxy)","name":"*","chunks":["server/app/page.js"],"async":false}}},"edgeRscModuleMapping":{},"entryCSSFiles":{"[project]/app/layout":["static/chunks/app_globals_73c377.css"],"[project]/app/page":["static/chunks/app_globals_73c377.css"],"[project]/app/favicon.ico":[]},"entryJSFiles":{"[project]/app/layout":["static/chunks/node_modules_90ff86._.js","static/chunks/_60515f._.js","static/chunks/app_layout_tsx_36ac26._.js"],"[project]/app/page":["static/chunks/node_modules_90ff86._.js","static/chunks/_60515f._.js","static/chunks/app_layout_tsx_36ac26._.js","static/chunks/_96ad38._.js","static/chunks/app_page_tsx_19cf49._.js"],"[project]/app/favicon.ico":["static/chunks/_2b2515._.js","static/chunks/app_favicon_ico_mjs_5930e7._.js"]}}
Repository Structure for app:
===================

├── layout.tsx
├── page.tsx


File Contents:
=============


FILE: app\layout.tsx
====================
'use client';

import { Auth0Provider } from '@auth0/auth0-react';
import ThemeProvider from "@/components/theme-provider";
import { Header } from "@/components/header";
import { Sidebar } from "@/components/sidebar";
import RequireAuth from "@/components/RequireAuth";
import "@/app/globals.css";

export default function RootLayout({ children }: { children: React.ReactNode }) {
  return (
    <html lang="en">
      <body>
        <Auth0Provider
          domain={process.env.NEXT_PUBLIC_AUTH0_DOMAIN!}
          clientId={process.env.NEXT_PUBLIC_AUTH0_CLIENT_ID!}
          authorizationParams={{
            redirect_uri: process.env.NEXT_PUBLIC_REDIRECT_URI!,
            audience: process.env.NEXT_PUBLIC_AUTH0_AUDIENCE!,
            scope: "openid profile email write:files",
            useRefreshTokens: true,
            useRefreshTokensFallback: false
          }}
        >
          <RequireAuth>
            <ThemeProvider>
              <div className="min-h-screen flex">
                <Sidebar />
                <div className="flex-1">
                  <Header />
                  <main className="app-container">{children}</main>
                </div>
              </div>
            </ThemeProvider>
          </RequireAuth>
        </Auth0Provider>
      </body>
    </html>
  );
}

FILE: app\page.tsx
==================
'use client';

import { Auth0Provider } from '@auth0/auth0-react';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card'
import { Button } from '@/components/ui/button'
import { FileText, Send, PlusCircle } from 'lucide-react'
import RequireAuth from '@/components/RequireAuth'

const Page = ({ children }: { children: React.ReactNode }) => {
  return (
    <Auth0Provider
      domain={process.env.NEXT_PUBLIC_AUTH0_DOMAIN!}
      clientId={process.env.NEXT_PUBLIC_AUTH0_CLIENT_ID!}
      authorizationParams={{
        redirect_uri: process.env.NEXT_PUBLIC_REDIRECT_URI!,
        audience: process.env.NEXT_PUBLIC_AUTH0_AUDIENCE!,
      }}
    >
      <RequireAuth>
        <div className="space-y-6">
          <div className="grid gap-4 md:grid-cols-2 lg:grid-cols-4">
            <Card>
              <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
                <CardTitle className="text-sm font-medium">Total Documents</CardTitle>
                <FileText className="h-4 w-4 text-muted-foreground" />
              </CardHeader>
              <CardContent>
                <div className="text-2xl font-bold">1,234</div>
                <p className="text-xs text-muted-foreground">+20% from last month</p>
              </CardContent>
            </Card>
            <Card>
              <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
                <CardTitle className="text-sm font-medium">Documents Sent</CardTitle>
                <Send className="h-4 w-4 text-muted-foreground" />
              </CardHeader>
              <CardContent>
                <div className="text-2xl font-bold">567</div>
                <p className="text-xs text-muted-foreground">+15% from last month</p>
              </CardContent>
            </Card>
            {/* Add more cards for other metrics */}
          </div>

          <div className="grid gap-4 md:grid-cols-2 lg:grid-cols-3">
            <Card>
              <CardHeader>
                <CardTitle>Quick Actions</CardTitle>
              </CardHeader>
              <CardContent className="flex flex-col space-y-2">
                <Button>
                  <PlusCircle className="mr-2 h-4 w-4" /> Create New Document
                </Button>
                <Button variant="outline">
                  <Send className="mr-2 h-4 w-4" /> Send Document
                </Button>
              </CardContent>
            </Card>
            <Card>
              <CardHeader>
                <CardTitle>Recent Documents</CardTitle>
              </CardHeader>
              <CardContent>
                <ul className="space-y-2">
                  <li className="flex justify-between">
                    <span>Q4 Financial Report.pdf</span>
                    <span className="text-muted-foreground">2 days ago</span>
                  </li>
                  <li className="flex justify-between">
                    <span>Project Proposal.docx</span>
                    <span className="text-muted-foreground">5 days ago</span>
                  </li>
                  {/* Add more recent documents */}
                </ul>
              </CardContent>
            </Card>
            <Card>
              <CardHeader>
                <CardTitle>Important Dates</CardTitle>
              </CardHeader>
              <CardContent>
                <ul className="space-y-2">
                  <li className="flex justify-between">
                    <span>Customer X Renewal</span>
                    <span className="text-muted-foreground">June 15, 2023</span>
                  </li>
                  <li className="flex justify-between">
                    <span>Board Meeting</span>
                    <span className="text-muted-foreground">June 30, 2023</span>
                  </li>
                  {/* Add more important dates */}
                </ul>
              </CardContent>
            </Card>
          </div>
        </div>
      </RequireAuth>
    </Auth0Provider>
  )
}

export default Page
Repository Structure for app:
===================

├── app-segment-config.js
├── app-segments.js


File Contents:
=============


FILE: node_modules\next\dist\build\segment-config\app\app-segment-config.js
===========================================================================
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    AppSegmentConfigSchemaKeys: null,
    parseAppSegmentConfig: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    AppSegmentConfigSchemaKeys: function() {
        return AppSegmentConfigSchemaKeys;
    },
    parseAppSegmentConfig: function() {
        return parseAppSegmentConfig;
    }
});
const _zod = require("next/dist/compiled/zod");
const _zod1 = require("../../../shared/lib/zod");
/**
 * The schema for configuration for a page.
 */ const AppSegmentConfigSchema = _zod.z.object({
    /**
   * The number of seconds to revalidate the page or false to disable revalidation.
   */ revalidate: _zod.z.union([
        _zod.z.number().int().nonnegative(),
        _zod.z.literal(false)
    ]).optional(),
    /**
   * Whether the page supports dynamic parameters.
   */ dynamicParams: _zod.z.boolean().optional(),
    /**
   * The dynamic behavior of the page.
   */ dynamic: _zod.z.enum([
        'auto',
        'error',
        'force-static',
        'force-dynamic'
    ]).optional(),
    /**
   * The caching behavior of the page.
   */ fetchCache: _zod.z.enum([
        'auto',
        'default-cache',
        'only-cache',
        'force-cache',
        'force-no-store',
        'default-no-store',
        'only-no-store'
    ]).optional(),
    /**
   * The preferred region for the page.
   */ preferredRegion: _zod.z.union([
        _zod.z.string(),
        _zod.z.array(_zod.z.string())
    ]).optional(),
    /**
   * Whether the page supports partial prerendering. When true, the page will be
   * served using partial prerendering. This setting will only take affect if
   * it's enabled via the `experimental.ppr = "incremental"` option.
   */ experimental_ppr: _zod.z.boolean().optional(),
    /**
   * The runtime to use for the page.
   */ runtime: _zod.z.enum([
        'edge',
        'nodejs'
    ]).optional(),
    /**
   * The maximum duration for the page in seconds.
   */ maxDuration: _zod.z.number().int().nonnegative().optional()
});
function parseAppSegmentConfig(data, route) {
    const parsed = AppSegmentConfigSchema.safeParse(data, {
        errorMap: (issue, ctx)=>{
            if (issue.path.length === 1 && issue.path[0] === 'revalidate') {
                return {
                    message: `Invalid revalidate value ${JSON.stringify(ctx.data)} on "${route}", must be a non-negative number or false`
                };
            }
            return {
                message: ctx.defaultError
            };
        }
    });
    if (!parsed.success) {
        throw (0, _zod1.formatZodError)(`Invalid segment configuration options detected for "${route}". Read more at https://nextjs.org/docs/app/api-reference/file-conventions/route-segment-config`, parsed.error);
    }
    return parsed.data;
}
const AppSegmentConfigSchemaKeys = AppSegmentConfigSchema.keyof().options;

//# sourceMappingURL=app-segment-config.js.map
FILE: node_modules\next\dist\build\segment-config\app\app-segments.js
=====================================================================
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "collectSegments", {
    enumerable: true,
    get: function() {
        return collectSegments;
    }
});
const _appsegmentconfig = require("./app-segment-config");
const _invarianterror = require("../../../shared/lib/invariant-error");
const _checks = require("../../../server/route-modules/checks");
const _clientreference = require("../../../lib/client-reference");
const _getsegmentparam = require("../../../server/app-render/get-segment-param");
const _appdirmodule = require("../../../server/lib/app-dir-module");
/**
 * Parses the app config and attaches it to the segment.
 */ function attach(segment, userland, route) {
    // If the userland is not an object, then we can't do anything with it.
    if (typeof userland !== 'object' || userland === null) {
        return;
    }
    // Try to parse the application configuration.
    const config = (0, _appsegmentconfig.parseAppSegmentConfig)(userland, route);
    // If there was any keys on the config, then attach it to the segment.
    if (Object.keys(config).length > 0) {
        segment.config = config;
    }
    if ('generateStaticParams' in userland && typeof userland.generateStaticParams === 'function') {
        var _segment_config;
        segment.generateStaticParams = userland.generateStaticParams;
        // Validate that `generateStaticParams` makes sense in this context.
        if (((_segment_config = segment.config) == null ? void 0 : _segment_config.runtime) === 'edge') {
            throw new Error('Edge runtime is not supported with `generateStaticParams`.');
        }
    }
}
/**
 * Walks the loader tree and collects the generate parameters for each segment.
 *
 * @param routeModule the app page route module
 * @returns the segments for the app page route module
 */ async function collectAppPageSegments(routeModule) {
    const segments = [];
    let current = routeModule.userland.loaderTree;
    while(current){
        var _getSegmentParam;
        const [name, parallelRoutes] = current;
        const { mod: userland, filePath } = await (0, _appdirmodule.getLayoutOrPageModule)(current);
        const isClientComponent = userland && (0, _clientreference.isClientReference)(userland);
        const isDynamicSegment = /^\[.*\]$/.test(name);
        const param = isDynamicSegment ? (_getSegmentParam = (0, _getsegmentparam.getSegmentParam)(name)) == null ? void 0 : _getSegmentParam.param : undefined;
        const segment = {
            name,
            param,
            filePath,
            config: undefined,
            isDynamicSegment,
            generateStaticParams: undefined
        };
        // Only server components can have app segment configurations. If this isn't
        // an object, then we should skip it. This can happen when parsing the
        // error components.
        if (!isClientComponent) {
            attach(segment, userland, routeModule.definition.pathname);
        }
        segments.push(segment);
        // Use this route's parallel route children as the next segment.
        current = parallelRoutes.children;
    }
    return segments;
}
/**
 * Collects the segments for a given app route module.
 *
 * @param routeModule the app route module
 * @returns the segments for the app route module
 */ function collectAppRouteSegments(routeModule) {
    // Get the pathname parts, slice off the first element (which is empty).
    const parts = routeModule.definition.pathname.split('/').slice(1);
    if (parts.length === 0) {
        throw new _invarianterror.InvariantError('Expected at least one segment');
    }
    // Generate all the segments.
    const segments = parts.map((name)=>{
        var _getSegmentParam;
        const isDynamicSegment = /^\[.*\]$/.test(name);
        const param = isDynamicSegment ? (_getSegmentParam = (0, _getsegmentparam.getSegmentParam)(name)) == null ? void 0 : _getSegmentParam.param : undefined;
        return {
            name,
            param,
            filePath: undefined,
            isDynamicSegment,
            config: undefined,
            generateStaticParams: undefined
        };
    });
    // We know we have at least one, we verified this above. We should get the
    // last segment which represents the root route module.
    const segment = segments[segments.length - 1];
    segment.filePath = routeModule.definition.filename;
    // Extract the segment config from the userland module.
    attach(segment, routeModule.userland, routeModule.definition.pathname);
    return segments;
}
function collectSegments({ routeModule }) {
    if ((0, _checks.isAppRouteRouteModule)(routeModule)) {
        return collectAppRouteSegments(routeModule);
    }
    if ((0, _checks.isAppPageRouteModule)(routeModule)) {
        return collectAppPageSegments(routeModule);
    }
    throw new _invarianterror.InvariantError('Expected a route module to be one of app route or page');
}

//# sourceMappingURL=app-segments.js.mapRepository Structure for app:
===================

├── hot-reloader-client.js
├── ReactDevOverlay.js


File Contents:
=============


FILE: node_modules\next\dist\client\components\react-dev-overlay\app\hot-reloader-client.js
===========================================================================================
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    default: null,
    waitForWebpackRuntimeHotUpdate: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    default: function() {
        return HotReload;
    },
    waitForWebpackRuntimeHotUpdate: function() {
        return waitForWebpackRuntimeHotUpdate;
    }
});
const _interop_require_default = require("@swc/helpers/_/_interop_require_default");
const _jsxruntime = require("react/jsx-runtime");
const _react = require("react");
const _stripansi = /*#__PURE__*/ _interop_require_default._(require("next/dist/compiled/strip-ansi"));
const _formatwebpackmessages = /*#__PURE__*/ _interop_require_default._(require("../internal/helpers/format-webpack-messages"));
const _navigation = require("../../navigation");
const _shared = require("../shared");
const _parsestack = require("../internal/helpers/parse-stack");
const _ReactDevOverlay = /*#__PURE__*/ _interop_require_default._(require("./ReactDevOverlay"));
const _useerrorhandler = require("../internal/helpers/use-error-handler");
const _runtimeerrorhandler = require("../internal/helpers/runtime-error-handler");
const _usewebsocket = require("../internal/helpers/use-websocket");
const _parsecomponentstack = require("../internal/helpers/parse-component-stack");
const _hotreloadertypes = require("../../../../server/dev/hot-reloader-types");
const _extractmodulesfromturbopackmessage = require("../../../../server/dev/extract-modules-from-turbopack-message");
const _navigationuntracked = require("../../navigation-untracked");
const _stitchederror = require("../internal/helpers/stitched-error");
let mostRecentCompilationHash = null;
let __nextDevClientId = Math.round(Math.random() * 100 + Date.now());
let reloading = false;
let startLatency = null;
let pendingHotUpdateWebpack = Promise.resolve();
let resolvePendingHotUpdateWebpack = ()=>{};
function setPendingHotUpdateWebpack() {
    pendingHotUpdateWebpack = new Promise((resolve)=>{
        resolvePendingHotUpdateWebpack = ()=>{
            resolve();
        };
    });
}
function waitForWebpackRuntimeHotUpdate() {
    return pendingHotUpdateWebpack;
}
function handleBeforeHotUpdateWebpack(dispatcher, hasUpdates) {
    if (hasUpdates) {
        dispatcher.onBeforeRefresh();
    }
}
function handleSuccessfulHotUpdateWebpack(dispatcher, sendMessage, updatedModules) {
    resolvePendingHotUpdateWebpack();
    dispatcher.onBuildOk();
    reportHmrLatency(sendMessage, updatedModules);
    dispatcher.onRefresh();
}
function reportHmrLatency(sendMessage, updatedModules) {
    if (!startLatency) return;
    let endLatency = Date.now();
    const latency = endLatency - startLatency;
    console.log("[Fast Refresh] done in " + latency + "ms");
    sendMessage(JSON.stringify({
        event: 'client-hmr-latency',
        id: window.__nextDevClientId,
        startTime: startLatency,
        endTime: endLatency,
        page: window.location.pathname,
        updatedModules,
        // Whether the page (tab) was hidden at the time the event occurred.
        // This can impact the accuracy of the event's timing.
        isPageHidden: document.visibilityState === 'hidden'
    }));
}
// There is a newer version of the code available.
function handleAvailableHash(hash) {
    // Update last known compilation hash.
    mostRecentCompilationHash = hash;
}
/**
 * Is there a newer version of this code available?
 * For webpack: Check if the hash changed compared to __webpack_hash__
 * For Turbopack: Always true because it doesn't have __webpack_hash__
 */ function isUpdateAvailable() {
    if (process.env.TURBOPACK) {
        return true;
    }
    /* globals __webpack_hash__ */ // __webpack_hash__ is the hash of the current compilation.
    // It's a global variable injected by Webpack.
    return mostRecentCompilationHash !== __webpack_hash__;
}
// Webpack disallows updates in other states.
function canApplyUpdates() {
    // @ts-expect-error module.hot exists
    return module.hot.status() === 'idle';
}
function afterApplyUpdates(fn) {
    if (canApplyUpdates()) {
        fn();
    } else {
        function handler(status) {
            if (status === 'idle') {
                // @ts-expect-error module.hot exists
                module.hot.removeStatusHandler(handler);
                fn();
            }
        }
        // @ts-expect-error module.hot exists
        module.hot.addStatusHandler(handler);
    }
}
function performFullReload(err, sendMessage) {
    const stackTrace = err && (err.stack && err.stack.split('\n').slice(0, 5).join('\n') || err.message || err + '');
    sendMessage(JSON.stringify({
        event: 'client-full-reload',
        stackTrace,
        hadRuntimeError: !!_runtimeerrorhandler.RuntimeErrorHandler.hadRuntimeError,
        dependencyChain: err ? err.dependencyChain : undefined
    }));
    if (reloading) return;
    reloading = true;
    window.location.reload();
}
// Attempt to update code on the fly, fall back to a hard reload.
function tryApplyUpdates(onBeforeUpdate, onHotUpdateSuccess, sendMessage, dispatcher) {
    if (!isUpdateAvailable() || !canApplyUpdates()) {
        resolvePendingHotUpdateWebpack();
        dispatcher.onBuildOk();
        reportHmrLatency(sendMessage, []);
        return;
    }
    function handleApplyUpdates(err, updatedModules) {
        if (err || _runtimeerrorhandler.RuntimeErrorHandler.hadRuntimeError || !updatedModules) {
            if (err) {
                console.warn('[Fast Refresh] performing full reload\n\n' + "Fast Refresh will perform a full reload when you edit a file that's imported by modules outside of the React rendering tree.\n" + 'You might have a file which exports a React component but also exports a value that is imported by a non-React component file.\n' + 'Consider migrating the non-React component export to a separate file and importing it into both files.\n\n' + 'It is also possible the parent component of the component you edited is a class component, which disables Fast Refresh.\n' + 'Fast Refresh requires at least one parent function component in your React tree.');
            } else if (_runtimeerrorhandler.RuntimeErrorHandler.hadRuntimeError) {
                console.warn(_shared.REACT_REFRESH_FULL_RELOAD_FROM_ERROR);
            }
            performFullReload(err, sendMessage);
            return;
        }
        const hasUpdates = Boolean(updatedModules.length);
        if (typeof onHotUpdateSuccess === 'function') {
            // Maybe we want to do something.
            onHotUpdateSuccess(updatedModules);
        }
        if (isUpdateAvailable()) {
            // While we were updating, there was a new update! Do it again.
            tryApplyUpdates(hasUpdates ? ()=>{} : onBeforeUpdate, hasUpdates ? ()=>dispatcher.onBuildOk() : onHotUpdateSuccess, sendMessage, dispatcher);
        } else {
            dispatcher.onBuildOk();
            if (process.env.__NEXT_TEST_MODE) {
                afterApplyUpdates(()=>{
                    if (self.__NEXT_HMR_CB) {
                        self.__NEXT_HMR_CB();
                        self.__NEXT_HMR_CB = null;
                    }
                });
            }
        }
    }
    // https://webpack.js.org/api/hot-module-replacement/#check
    // @ts-expect-error module.hot exists
    module.hot.check(/* autoApply */ false).then((updatedModules)=>{
        if (!updatedModules) {
            return null;
        }
        if (typeof onBeforeUpdate === 'function') {
            const hasUpdates = Boolean(updatedModules.length);
            onBeforeUpdate(hasUpdates);
        }
        // https://webpack.js.org/api/hot-module-replacement/#apply
        // @ts-expect-error module.hot exists
        return module.hot.apply();
    }).then((updatedModules)=>{
        handleApplyUpdates(null, updatedModules);
    }, (err)=>{
        handleApplyUpdates(err, null);
    });
}
/** Handles messages from the sevrer for the App Router. */ function processMessage(obj, sendMessage, processTurbopackMessage, router, dispatcher, appIsrManifestRef, pathnameRef) {
    if (!('action' in obj)) {
        return;
    }
    function handleErrors(errors) {
        // "Massage" webpack messages.
        const formatted = (0, _formatwebpackmessages.default)({
            errors: errors,
            warnings: []
        });
        // Only show the first error.
        dispatcher.onBuildError(formatted.errors[0]);
        // Also log them to the console.
        for(let i = 0; i < formatted.errors.length; i++){
            console.error((0, _stripansi.default)(formatted.errors[i]));
        }
        // Do not attempt to reload now.
        // We will reload on next success instead.
        if (process.env.__NEXT_TEST_MODE) {
            if (self.__NEXT_HMR_CB) {
                self.__NEXT_HMR_CB(formatted.errors[0]);
                self.__NEXT_HMR_CB = null;
            }
        }
    }
    function handleHotUpdate() {
        if (process.env.TURBOPACK) {
            dispatcher.onBuildOk();
        } else {
            tryApplyUpdates(function onBeforeHotUpdate(hasUpdates) {
                handleBeforeHotUpdateWebpack(dispatcher, hasUpdates);
            }, function onSuccessfulHotUpdate(webpackUpdatedModules) {
                // Only dismiss it when we're sure it's a hot update.
                // Otherwise it would flicker right before the reload.
                handleSuccessfulHotUpdateWebpack(dispatcher, sendMessage, webpackUpdatedModules);
            }, sendMessage, dispatcher);
        }
    }
    switch(obj.action){
        case _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.APP_ISR_MANIFEST:
            {
                if (process.env.__NEXT_APP_ISR_INDICATOR) {
                    if (appIsrManifestRef) {
                        appIsrManifestRef.current = obj.data;
                        // handle initial status on receiving manifest
                        // navigation is handled in useEffect for pathname changes
                        // as we'll receive the updated manifest before usePathname
                        // triggers for new value
                        if (pathnameRef.current in obj.data) {
                            var _localStorage;
                            // the indicator can be hidden for an hour.
                            // check if it's still hidden
                            const indicatorHiddenAt = Number((_localStorage = localStorage) == null ? void 0 : _localStorage.getItem('__NEXT_DISMISS_PRERENDER_INDICATOR'));
                            const isHidden = indicatorHiddenAt && !isNaN(indicatorHiddenAt) && Date.now() < indicatorHiddenAt;
                            if (!isHidden) {
                                dispatcher.onStaticIndicator(true);
                            }
                        } else {
                            dispatcher.onStaticIndicator(false);
                        }
                    }
                }
                break;
            }
        case _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.BUILDING:
            {
                startLatency = Date.now();
                if (!process.env.TURBOPACK) {
                    setPendingHotUpdateWebpack();
                }
                console.log('[Fast Refresh] rebuilding');
                break;
            }
        case _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.BUILT:
        case _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.SYNC:
            {
                if (obj.hash) {
                    handleAvailableHash(obj.hash);
                }
                const { errors, warnings } = obj;
                // Is undefined when it's a 'built' event
                if ('versionInfo' in obj) dispatcher.onVersionInfo(obj.versionInfo);
                if ('debug' in obj && obj.debug) dispatcher.onDebugInfo(obj.debug);
                const hasErrors = Boolean(errors && errors.length);
                // Compilation with errors (e.g. syntax error or missing modules).
                if (hasErrors) {
                    sendMessage(JSON.stringify({
                        event: 'client-error',
                        errorCount: errors.length,
                        clientId: __nextDevClientId
                    }));
                    handleErrors(errors);
                    return;
                }
                const hasWarnings = Boolean(warnings && warnings.length);
                if (hasWarnings) {
                    sendMessage(JSON.stringify({
                        event: 'client-warning',
                        warningCount: warnings.length,
                        clientId: __nextDevClientId
                    }));
                    // Print warnings to the console.
                    const formattedMessages = (0, _formatwebpackmessages.default)({
                        warnings: warnings,
                        errors: []
                    });
                    for(let i = 0; i < formattedMessages.warnings.length; i++){
                        if (i === 5) {
                            console.warn('There were more warnings in other files.\n' + 'You can find a complete log in the terminal.');
                            break;
                        }
                        console.warn((0, _stripansi.default)(formattedMessages.warnings[i]));
                    }
                // No early return here as we need to apply modules in the same way between warnings only and compiles without warnings
                }
                sendMessage(JSON.stringify({
                    event: 'client-success',
                    clientId: __nextDevClientId
                }));
                if (obj.action === _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.BUILT) {
                    // Handle hot updates
                    handleHotUpdate();
                }
                return;
            }
        case _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.TURBOPACK_CONNECTED:
            {
                processTurbopackMessage({
                    type: _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.TURBOPACK_CONNECTED,
                    data: {
                        sessionId: obj.data.sessionId
                    }
                });
                break;
            }
        case _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.TURBOPACK_MESSAGE:
            {
                const updatedModules = (0, _extractmodulesfromturbopackmessage.extractModulesFromTurbopackMessage)(obj.data);
                dispatcher.onBeforeRefresh();
                processTurbopackMessage({
                    type: _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.TURBOPACK_MESSAGE,
                    data: obj.data
                });
                dispatcher.onRefresh();
                if (_runtimeerrorhandler.RuntimeErrorHandler.hadRuntimeError) {
                    console.warn(_shared.REACT_REFRESH_FULL_RELOAD_FROM_ERROR);
                    performFullReload(null, sendMessage);
                }
                reportHmrLatency(sendMessage, updatedModules);
                break;
            }
        // TODO-APP: make server component change more granular
        case _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.SERVER_COMPONENT_CHANGES:
            {
                sendMessage(JSON.stringify({
                    event: 'server-component-reload-page',
                    clientId: __nextDevClientId
                }));
                if (_runtimeerrorhandler.RuntimeErrorHandler.hadRuntimeError) {
                    if (reloading) return;
                    reloading = true;
                    return window.location.reload();
                }
                (0, _react.startTransition)(()=>{
                    router.hmrRefresh();
                    dispatcher.onRefresh();
                });
                if (process.env.__NEXT_TEST_MODE) {
                    if (self.__NEXT_HMR_CB) {
                        self.__NEXT_HMR_CB();
                        self.__NEXT_HMR_CB = null;
                    }
                }
                return;
            }
        case _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.RELOAD_PAGE:
            {
                sendMessage(JSON.stringify({
                    event: 'client-reload-page',
                    clientId: __nextDevClientId
                }));
                if (reloading) return;
                reloading = true;
                return window.location.reload();
            }
        case _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.ADDED_PAGE:
        case _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.REMOVED_PAGE:
            {
                // TODO-APP: potentially only refresh if the currently viewed page was added/removed.
                return router.hmrRefresh();
            }
        case _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.SERVER_ERROR:
            {
                const { errorJSON } = obj;
                if (errorJSON) {
                    const { message, stack } = JSON.parse(errorJSON);
                    const error = new Error(message);
                    error.stack = stack;
                    handleErrors([
                        error
                    ]);
                }
                return;
            }
        case _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.DEV_PAGES_MANIFEST_UPDATE:
            {
                return;
            }
        default:
            {}
    }
}
function HotReload(param) {
    let { assetPrefix, children } = param;
    const [state, dispatch] = (0, _shared.useErrorOverlayReducer)();
    const dispatcher = (0, _react.useMemo)(()=>{
        return {
            onBuildOk () {
                dispatch({
                    type: _shared.ACTION_BUILD_OK
                });
            },
            onBuildError (message) {
                dispatch({
                    type: _shared.ACTION_BUILD_ERROR,
                    message
                });
            },
            onBeforeRefresh () {
                dispatch({
                    type: _shared.ACTION_BEFORE_REFRESH
                });
            },
            onRefresh () {
                dispatch({
                    type: _shared.ACTION_REFRESH
                });
            },
            onVersionInfo (versionInfo) {
                dispatch({
                    type: _shared.ACTION_VERSION_INFO,
                    versionInfo
                });
            },
            onStaticIndicator (status) {
                dispatch({
                    type: _shared.ACTION_STATIC_INDICATOR,
                    staticIndicator: status
                });
            },
            onDebugInfo (debugInfo) {
                dispatch({
                    type: _shared.ACTION_DEBUG_INFO,
                    debugInfo
                });
            }
        };
    }, [
        dispatch
    ]);
    const handleOnUnhandledError = (0, _react.useCallback)((error)=>{
        const errorDetails = error.details;
        // Component stack is added to the error in use-error-handler in case there was a hydration error
        const componentStackTrace = error._componentStack || (errorDetails == null ? void 0 : errorDetails.componentStack);
        const warning = errorDetails == null ? void 0 : errorDetails.warning;
        const stitchedError = (0, _stitchederror.getReactStitchedError)(error);
        dispatch({
            type: _shared.ACTION_UNHANDLED_ERROR,
            reason: stitchedError,
            frames: (0, _parsestack.parseStack)(stitchedError.stack || ''),
            componentStackFrames: typeof componentStackTrace === 'string' ? (0, _parsecomponentstack.parseComponentStack)(componentStackTrace) : undefined,
            warning
        });
    }, [
        dispatch
    ]);
    const handleOnUnhandledRejection = (0, _react.useCallback)((reason)=>{
        const stitchedError = (0, _stitchederror.getReactStitchedError)(reason);
        dispatch({
            type: _shared.ACTION_UNHANDLED_REJECTION,
            reason: stitchedError,
            frames: (0, _parsestack.parseStack)(stitchedError.stack || '')
        });
    }, [
        dispatch
    ]);
    (0, _useerrorhandler.useErrorHandler)(handleOnUnhandledError, handleOnUnhandledRejection);
    const webSocketRef = (0, _usewebsocket.useWebsocket)(assetPrefix);
    (0, _usewebsocket.useWebsocketPing)(webSocketRef);
    const sendMessage = (0, _usewebsocket.useSendMessage)(webSocketRef);
    const processTurbopackMessage = (0, _usewebsocket.useTurbopack)(sendMessage, (err)=>performFullReload(err, sendMessage));
    const router = (0, _navigation.useRouter)();
    // We don't want access of the pathname for the dev tools to trigger a dynamic
    // access (as the dev overlay will never be present in production).
    const pathname = (0, _navigationuntracked.useUntrackedPathname)();
    const appIsrManifestRef = (0, _react.useRef)({});
    const pathnameRef = (0, _react.useRef)(pathname);
    if (process.env.__NEXT_APP_ISR_INDICATOR) {
        // this conditional is only for dead-code elimination which
        // isn't a runtime conditional only build-time so ignore hooks rule
        // eslint-disable-next-line react-hooks/rules-of-hooks
        (0, _react.useEffect)(()=>{
            pathnameRef.current = pathname;
            const appIsrManifest = appIsrManifestRef.current;
            if (appIsrManifest) {
                if (pathname && pathname in appIsrManifest) {
                    var _localStorage;
                    const indicatorHiddenAt = Number((_localStorage = localStorage) == null ? void 0 : _localStorage.getItem('__NEXT_DISMISS_PRERENDER_INDICATOR'));
                    const isHidden = indicatorHiddenAt && !isNaN(indicatorHiddenAt) && Date.now() < indicatorHiddenAt;
                    if (!isHidden) {
                        dispatcher.onStaticIndicator(true);
                    }
                } else {
                    dispatcher.onStaticIndicator(false);
                }
            }
        }, [
            pathname,
            dispatcher
        ]);
    }
    (0, _react.useEffect)(()=>{
        const websocket = webSocketRef.current;
        if (!websocket) return;
        const handler = (event)=>{
            try {
                const obj = JSON.parse(event.data);
                processMessage(obj, sendMessage, processTurbopackMessage, router, dispatcher, appIsrManifestRef, pathnameRef);
            } catch (err) {
                var _err_stack;
                console.warn('[HMR] Invalid message: ' + JSON.stringify(event.data) + '\n' + ((_err_stack = err == null ? void 0 : err.stack) != null ? _err_stack : ''));
            }
        };
        websocket.addEventListener('message', handler);
        return ()=>websocket.removeEventListener('message', handler);
    }, [
        sendMessage,
        router,
        webSocketRef,
        dispatcher,
        processTurbopackMessage,
        appIsrManifestRef
    ]);
    return /*#__PURE__*/ (0, _jsxruntime.jsx)(_ReactDevOverlay.default, {
        state: state,
        dispatcher: dispatcher,
        children: children
    });
}

if ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {
  Object.defineProperty(exports.default, '__esModule', { value: true });
  Object.assign(exports.default, exports);
  module.exports = exports.default;
}

//# sourceMappingURL=hot-reloader-client.js.map
FILE: node_modules\next\dist\client\components\react-dev-overlay\app\ReactDevOverlay.js
=======================================================================================
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function() {
        return ReactDevOverlay;
    }
});
const _interop_require_default = require("@swc/helpers/_/_interop_require_default");
const _jsxruntime = require("react/jsx-runtime");
const _react = /*#__PURE__*/ _interop_require_default._(require("react"));
const _ShadowPortal = require("../internal/components/ShadowPortal");
const _BuildError = require("../internal/container/BuildError");
const _Errors = require("../internal/container/Errors");
const _StaticIndicator = require("../internal/container/StaticIndicator");
const _Base = require("../internal/styles/Base");
const _ComponentStyles = require("../internal/styles/ComponentStyles");
const _CssReset = require("../internal/styles/CssReset");
const _rootlayoutmissingtagserror = require("../internal/container/root-layout-missing-tags-error");
const _runtimeerrorhandler = require("../internal/helpers/runtime-error-handler");
class ReactDevOverlay extends _react.default.PureComponent {
    static getDerivedStateFromError(error) {
        if (!error.stack) return {
            isReactError: false
        };
        _runtimeerrorhandler.RuntimeErrorHandler.hadRuntimeError = true;
        return {
            isReactError: true
        };
    }
    render() {
        var _state_rootLayoutMissingTags;
        const { state, children, dispatcher } = this.props;
        const { isReactError } = this.state;
        const hasBuildError = state.buildError != null;
        const hasRuntimeErrors = Boolean(state.errors.length);
        const hasStaticIndicator = state.staticIndicator;
        const debugInfo = state.debugInfo;
        return /*#__PURE__*/ (0, _jsxruntime.jsxs)(_jsxruntime.Fragment, {
            children: [
                isReactError ? /*#__PURE__*/ (0, _jsxruntime.jsxs)("html", {
                    children: [
                        /*#__PURE__*/ (0, _jsxruntime.jsx)("head", {}),
                        /*#__PURE__*/ (0, _jsxruntime.jsx)("body", {})
                    ]
                }) : children,
                /*#__PURE__*/ (0, _jsxruntime.jsxs)(_ShadowPortal.ShadowPortal, {
                    children: [
                        /*#__PURE__*/ (0, _jsxruntime.jsx)(_CssReset.CssReset, {}),
                        /*#__PURE__*/ (0, _jsxruntime.jsx)(_Base.Base, {}),
                        /*#__PURE__*/ (0, _jsxruntime.jsx)(_ComponentStyles.ComponentStyles, {}),
                        ((_state_rootLayoutMissingTags = state.rootLayoutMissingTags) == null ? void 0 : _state_rootLayoutMissingTags.length) ? /*#__PURE__*/ (0, _jsxruntime.jsx)(_rootlayoutmissingtagserror.RootLayoutMissingTagsError, {
                            missingTags: state.rootLayoutMissingTags
                        }) : hasBuildError ? /*#__PURE__*/ (0, _jsxruntime.jsx)(_BuildError.BuildError, {
                            message: state.buildError,
                            versionInfo: state.versionInfo
                        }) : /*#__PURE__*/ (0, _jsxruntime.jsxs)(_jsxruntime.Fragment, {
                            children: [
                                hasRuntimeErrors ? /*#__PURE__*/ (0, _jsxruntime.jsx)(_Errors.Errors, {
                                    isAppDir: true,
                                    initialDisplayState: isReactError ? 'fullscreen' : 'minimized',
                                    errors: state.errors,
                                    versionInfo: state.versionInfo,
                                    hasStaticIndicator: hasStaticIndicator,
                                    debugInfo: debugInfo
                                }) : null,
                                hasStaticIndicator && /*#__PURE__*/ (0, _jsxruntime.jsx)(_StaticIndicator.StaticIndicator, {
                                    dispatcher: dispatcher
                                })
                            ]
                        })
                    ]
                })
            ]
        });
    }
    constructor(...args){
        super(...args);
        this.state = {
            isReactError: false
        };
    }
}

if ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {
  Object.defineProperty(exports.default, '__esModule', { value: true });
  Object.assign(exports.default, exports);
  module.exports = exports.default;
}

//# sourceMappingURL=ReactDevOverlay.js.mapRepository Structure for app:
===================

├── app-segment-config.js
├── app-segments.js


File Contents:
=============


FILE: node_modules\next\dist\esm\build\segment-config\app\app-segment-config.js
===============================================================================
import { z } from 'next/dist/compiled/zod';
import { formatZodError } from '../../../shared/lib/zod';
/**
 * The schema for configuration for a page.
 */ const AppSegmentConfigSchema = z.object({
    /**
   * The number of seconds to revalidate the page or false to disable revalidation.
   */ revalidate: z.union([
        z.number().int().nonnegative(),
        z.literal(false)
    ]).optional(),
    /**
   * Whether the page supports dynamic parameters.
   */ dynamicParams: z.boolean().optional(),
    /**
   * The dynamic behavior of the page.
   */ dynamic: z.enum([
        'auto',
        'error',
        'force-static',
        'force-dynamic'
    ]).optional(),
    /**
   * The caching behavior of the page.
   */ fetchCache: z.enum([
        'auto',
        'default-cache',
        'only-cache',
        'force-cache',
        'force-no-store',
        'default-no-store',
        'only-no-store'
    ]).optional(),
    /**
   * The preferred region for the page.
   */ preferredRegion: z.union([
        z.string(),
        z.array(z.string())
    ]).optional(),
    /**
   * Whether the page supports partial prerendering. When true, the page will be
   * served using partial prerendering. This setting will only take affect if
   * it's enabled via the `experimental.ppr = "incremental"` option.
   */ experimental_ppr: z.boolean().optional(),
    /**
   * The runtime to use for the page.
   */ runtime: z.enum([
        'edge',
        'nodejs'
    ]).optional(),
    /**
   * The maximum duration for the page in seconds.
   */ maxDuration: z.number().int().nonnegative().optional()
});
/**
 * Parse the app segment config.
 * @param data - The data to parse.
 * @param route - The route of the app.
 * @returns The parsed app segment config.
 */ export function parseAppSegmentConfig(data, route) {
    const parsed = AppSegmentConfigSchema.safeParse(data, {
        errorMap: (issue, ctx)=>{
            if (issue.path.length === 1 && issue.path[0] === 'revalidate') {
                return {
                    message: `Invalid revalidate value ${JSON.stringify(ctx.data)} on "${route}", must be a non-negative number or false`
                };
            }
            return {
                message: ctx.defaultError
            };
        }
    });
    if (!parsed.success) {
        throw formatZodError(`Invalid segment configuration options detected for "${route}". Read more at https://nextjs.org/docs/app/api-reference/file-conventions/route-segment-config`, parsed.error);
    }
    return parsed.data;
}
/**
 * The keys of the configuration for a page.
 *
 * @internal - required to exclude zod types from the build
 */ export const AppSegmentConfigSchemaKeys = AppSegmentConfigSchema.keyof().options;

//# sourceMappingURL=app-segment-config.js.map
FILE: node_modules\next\dist\esm\build\segment-config\app\app-segments.js
=========================================================================
import { parseAppSegmentConfig } from './app-segment-config';
import { InvariantError } from '../../../shared/lib/invariant-error';
import { isAppRouteRouteModule, isAppPageRouteModule } from '../../../server/route-modules/checks';
import { isClientReference } from '../../../lib/client-reference';
import { getSegmentParam } from '../../../server/app-render/get-segment-param';
import { getLayoutOrPageModule } from '../../../server/lib/app-dir-module';
/**
 * Parses the app config and attaches it to the segment.
 */ function attach(segment, userland, route) {
    // If the userland is not an object, then we can't do anything with it.
    if (typeof userland !== 'object' || userland === null) {
        return;
    }
    // Try to parse the application configuration.
    const config = parseAppSegmentConfig(userland, route);
    // If there was any keys on the config, then attach it to the segment.
    if (Object.keys(config).length > 0) {
        segment.config = config;
    }
    if ('generateStaticParams' in userland && typeof userland.generateStaticParams === 'function') {
        var _segment_config;
        segment.generateStaticParams = userland.generateStaticParams;
        // Validate that `generateStaticParams` makes sense in this context.
        if (((_segment_config = segment.config) == null ? void 0 : _segment_config.runtime) === 'edge') {
            throw new Error('Edge runtime is not supported with `generateStaticParams`.');
        }
    }
}
/**
 * Walks the loader tree and collects the generate parameters for each segment.
 *
 * @param routeModule the app page route module
 * @returns the segments for the app page route module
 */ async function collectAppPageSegments(routeModule) {
    const segments = [];
    let current = routeModule.userland.loaderTree;
    while(current){
        var _getSegmentParam;
        const [name, parallelRoutes] = current;
        const { mod: userland, filePath } = await getLayoutOrPageModule(current);
        const isClientComponent = userland && isClientReference(userland);
        const isDynamicSegment = /^\[.*\]$/.test(name);
        const param = isDynamicSegment ? (_getSegmentParam = getSegmentParam(name)) == null ? void 0 : _getSegmentParam.param : undefined;
        const segment = {
            name,
            param,
            filePath,
            config: undefined,
            isDynamicSegment,
            generateStaticParams: undefined
        };
        // Only server components can have app segment configurations. If this isn't
        // an object, then we should skip it. This can happen when parsing the
        // error components.
        if (!isClientComponent) {
            attach(segment, userland, routeModule.definition.pathname);
        }
        segments.push(segment);
        // Use this route's parallel route children as the next segment.
        current = parallelRoutes.children;
    }
    return segments;
}
/**
 * Collects the segments for a given app route module.
 *
 * @param routeModule the app route module
 * @returns the segments for the app route module
 */ function collectAppRouteSegments(routeModule) {
    // Get the pathname parts, slice off the first element (which is empty).
    const parts = routeModule.definition.pathname.split('/').slice(1);
    if (parts.length === 0) {
        throw new InvariantError('Expected at least one segment');
    }
    // Generate all the segments.
    const segments = parts.map((name)=>{
        var _getSegmentParam;
        const isDynamicSegment = /^\[.*\]$/.test(name);
        const param = isDynamicSegment ? (_getSegmentParam = getSegmentParam(name)) == null ? void 0 : _getSegmentParam.param : undefined;
        return {
            name,
            param,
            filePath: undefined,
            isDynamicSegment,
            config: undefined,
            generateStaticParams: undefined
        };
    });
    // We know we have at least one, we verified this above. We should get the
    // last segment which represents the root route module.
    const segment = segments[segments.length - 1];
    segment.filePath = routeModule.definition.filename;
    // Extract the segment config from the userland module.
    attach(segment, routeModule.userland, routeModule.definition.pathname);
    return segments;
}
/**
 * Collects the segments for a given route module.
 *
 * @param components the loaded components
 * @returns the segments for the route module
 */ export function collectSegments({ routeModule }) {
    if (isAppRouteRouteModule(routeModule)) {
        return collectAppRouteSegments(routeModule);
    }
    if (isAppPageRouteModule(routeModule)) {
        return collectAppPageSegments(routeModule);
    }
    throw new InvariantError('Expected a route module to be one of app route or page');
}

//# sourceMappingURL=app-segments.js.mapRepository Structure for app:
===================

├── hot-reloader-client.js
├── ReactDevOverlay.js


File Contents:
=============


FILE: node_modules\next\dist\esm\client\components\react-dev-overlay\app\hot-reloader-client.js
===============================================================================================
import { jsx as _jsx } from "react/jsx-runtime";
import { useCallback, useEffect, startTransition, useMemo, useRef } from 'react';
import stripAnsi from 'next/dist/compiled/strip-ansi';
import formatWebpackMessages from '../internal/helpers/format-webpack-messages';
import { useRouter } from '../../navigation';
import { ACTION_BEFORE_REFRESH, ACTION_BUILD_ERROR, ACTION_BUILD_OK, ACTION_DEBUG_INFO, ACTION_REFRESH, ACTION_STATIC_INDICATOR, ACTION_UNHANDLED_ERROR, ACTION_UNHANDLED_REJECTION, ACTION_VERSION_INFO, useErrorOverlayReducer } from '../shared';
import { parseStack } from '../internal/helpers/parse-stack';
import ReactDevOverlay from './ReactDevOverlay';
import { useErrorHandler } from '../internal/helpers/use-error-handler';
import { RuntimeErrorHandler } from '../internal/helpers/runtime-error-handler';
import { useSendMessage, useTurbopack, useWebsocket, useWebsocketPing } from '../internal/helpers/use-websocket';
import { parseComponentStack } from '../internal/helpers/parse-component-stack';
import { HMR_ACTIONS_SENT_TO_BROWSER } from '../../../../server/dev/hot-reloader-types';
import { extractModulesFromTurbopackMessage } from '../../../../server/dev/extract-modules-from-turbopack-message';
import { REACT_REFRESH_FULL_RELOAD_FROM_ERROR } from '../shared';
import { useUntrackedPathname } from '../../navigation-untracked';
import { getReactStitchedError } from '../internal/helpers/stitched-error';
let mostRecentCompilationHash = null;
let __nextDevClientId = Math.round(Math.random() * 100 + Date.now());
let reloading = false;
let startLatency = null;
let pendingHotUpdateWebpack = Promise.resolve();
let resolvePendingHotUpdateWebpack = ()=>{};
function setPendingHotUpdateWebpack() {
    pendingHotUpdateWebpack = new Promise((resolve)=>{
        resolvePendingHotUpdateWebpack = ()=>{
            resolve();
        };
    });
}
export function waitForWebpackRuntimeHotUpdate() {
    return pendingHotUpdateWebpack;
}
function handleBeforeHotUpdateWebpack(dispatcher, hasUpdates) {
    if (hasUpdates) {
        dispatcher.onBeforeRefresh();
    }
}
function handleSuccessfulHotUpdateWebpack(dispatcher, sendMessage, updatedModules) {
    resolvePendingHotUpdateWebpack();
    dispatcher.onBuildOk();
    reportHmrLatency(sendMessage, updatedModules);
    dispatcher.onRefresh();
}
function reportHmrLatency(sendMessage, updatedModules) {
    if (!startLatency) return;
    let endLatency = Date.now();
    const latency = endLatency - startLatency;
    console.log("[Fast Refresh] done in " + latency + "ms");
    sendMessage(JSON.stringify({
        event: 'client-hmr-latency',
        id: window.__nextDevClientId,
        startTime: startLatency,
        endTime: endLatency,
        page: window.location.pathname,
        updatedModules,
        // Whether the page (tab) was hidden at the time the event occurred.
        // This can impact the accuracy of the event's timing.
        isPageHidden: document.visibilityState === 'hidden'
    }));
}
// There is a newer version of the code available.
function handleAvailableHash(hash) {
    // Update last known compilation hash.
    mostRecentCompilationHash = hash;
}
/**
 * Is there a newer version of this code available?
 * For webpack: Check if the hash changed compared to __webpack_hash__
 * For Turbopack: Always true because it doesn't have __webpack_hash__
 */ function isUpdateAvailable() {
    if (process.env.TURBOPACK) {
        return true;
    }
    /* globals __webpack_hash__ */ // __webpack_hash__ is the hash of the current compilation.
    // It's a global variable injected by Webpack.
    return mostRecentCompilationHash !== __webpack_hash__;
}
// Webpack disallows updates in other states.
function canApplyUpdates() {
    // @ts-expect-error module.hot exists
    return module.hot.status() === 'idle';
}
function afterApplyUpdates(fn) {
    if (canApplyUpdates()) {
        fn();
    } else {
        function handler(status) {
            if (status === 'idle') {
                // @ts-expect-error module.hot exists
                module.hot.removeStatusHandler(handler);
                fn();
            }
        }
        // @ts-expect-error module.hot exists
        module.hot.addStatusHandler(handler);
    }
}
function performFullReload(err, sendMessage) {
    const stackTrace = err && (err.stack && err.stack.split('\n').slice(0, 5).join('\n') || err.message || err + '');
    sendMessage(JSON.stringify({
        event: 'client-full-reload',
        stackTrace,
        hadRuntimeError: !!RuntimeErrorHandler.hadRuntimeError,
        dependencyChain: err ? err.dependencyChain : undefined
    }));
    if (reloading) return;
    reloading = true;
    window.location.reload();
}
// Attempt to update code on the fly, fall back to a hard reload.
function tryApplyUpdates(onBeforeUpdate, onHotUpdateSuccess, sendMessage, dispatcher) {
    if (!isUpdateAvailable() || !canApplyUpdates()) {
        resolvePendingHotUpdateWebpack();
        dispatcher.onBuildOk();
        reportHmrLatency(sendMessage, []);
        return;
    }
    function handleApplyUpdates(err, updatedModules) {
        if (err || RuntimeErrorHandler.hadRuntimeError || !updatedModules) {
            if (err) {
                console.warn('[Fast Refresh] performing full reload\n\n' + "Fast Refresh will perform a full reload when you edit a file that's imported by modules outside of the React rendering tree.\n" + 'You might have a file which exports a React component but also exports a value that is imported by a non-React component file.\n' + 'Consider migrating the non-React component export to a separate file and importing it into both files.\n\n' + 'It is also possible the parent component of the component you edited is a class component, which disables Fast Refresh.\n' + 'Fast Refresh requires at least one parent function component in your React tree.');
            } else if (RuntimeErrorHandler.hadRuntimeError) {
                console.warn(REACT_REFRESH_FULL_RELOAD_FROM_ERROR);
            }
            performFullReload(err, sendMessage);
            return;
        }
        const hasUpdates = Boolean(updatedModules.length);
        if (typeof onHotUpdateSuccess === 'function') {
            // Maybe we want to do something.
            onHotUpdateSuccess(updatedModules);
        }
        if (isUpdateAvailable()) {
            // While we were updating, there was a new update! Do it again.
            tryApplyUpdates(hasUpdates ? ()=>{} : onBeforeUpdate, hasUpdates ? ()=>dispatcher.onBuildOk() : onHotUpdateSuccess, sendMessage, dispatcher);
        } else {
            dispatcher.onBuildOk();
            if (process.env.__NEXT_TEST_MODE) {
                afterApplyUpdates(()=>{
                    if (self.__NEXT_HMR_CB) {
                        self.__NEXT_HMR_CB();
                        self.__NEXT_HMR_CB = null;
                    }
                });
            }
        }
    }
    // https://webpack.js.org/api/hot-module-replacement/#check
    // @ts-expect-error module.hot exists
    module.hot.check(/* autoApply */ false).then((updatedModules)=>{
        if (!updatedModules) {
            return null;
        }
        if (typeof onBeforeUpdate === 'function') {
            const hasUpdates = Boolean(updatedModules.length);
            onBeforeUpdate(hasUpdates);
        }
        // https://webpack.js.org/api/hot-module-replacement/#apply
        // @ts-expect-error module.hot exists
        return module.hot.apply();
    }).then((updatedModules)=>{
        handleApplyUpdates(null, updatedModules);
    }, (err)=>{
        handleApplyUpdates(err, null);
    });
}
/** Handles messages from the sevrer for the App Router. */ function processMessage(obj, sendMessage, processTurbopackMessage, router, dispatcher, appIsrManifestRef, pathnameRef) {
    if (!('action' in obj)) {
        return;
    }
    function handleErrors(errors) {
        // "Massage" webpack messages.
        const formatted = formatWebpackMessages({
            errors: errors,
            warnings: []
        });
        // Only show the first error.
        dispatcher.onBuildError(formatted.errors[0]);
        // Also log them to the console.
        for(let i = 0; i < formatted.errors.length; i++){
            console.error(stripAnsi(formatted.errors[i]));
        }
        // Do not attempt to reload now.
        // We will reload on next success instead.
        if (process.env.__NEXT_TEST_MODE) {
            if (self.__NEXT_HMR_CB) {
                self.__NEXT_HMR_CB(formatted.errors[0]);
                self.__NEXT_HMR_CB = null;
            }
        }
    }
    function handleHotUpdate() {
        if (process.env.TURBOPACK) {
            dispatcher.onBuildOk();
        } else {
            tryApplyUpdates(function onBeforeHotUpdate(hasUpdates) {
                handleBeforeHotUpdateWebpack(dispatcher, hasUpdates);
            }, function onSuccessfulHotUpdate(webpackUpdatedModules) {
                // Only dismiss it when we're sure it's a hot update.
                // Otherwise it would flicker right before the reload.
                handleSuccessfulHotUpdateWebpack(dispatcher, sendMessage, webpackUpdatedModules);
            }, sendMessage, dispatcher);
        }
    }
    switch(obj.action){
        case HMR_ACTIONS_SENT_TO_BROWSER.APP_ISR_MANIFEST:
            {
                if (process.env.__NEXT_APP_ISR_INDICATOR) {
                    if (appIsrManifestRef) {
                        appIsrManifestRef.current = obj.data;
                        // handle initial status on receiving manifest
                        // navigation is handled in useEffect for pathname changes
                        // as we'll receive the updated manifest before usePathname
                        // triggers for new value
                        if (pathnameRef.current in obj.data) {
                            var _localStorage;
                            // the indicator can be hidden for an hour.
                            // check if it's still hidden
                            const indicatorHiddenAt = Number((_localStorage = localStorage) == null ? void 0 : _localStorage.getItem('__NEXT_DISMISS_PRERENDER_INDICATOR'));
                            const isHidden = indicatorHiddenAt && !isNaN(indicatorHiddenAt) && Date.now() < indicatorHiddenAt;
                            if (!isHidden) {
                                dispatcher.onStaticIndicator(true);
                            }
                        } else {
                            dispatcher.onStaticIndicator(false);
                        }
                    }
                }
                break;
            }
        case HMR_ACTIONS_SENT_TO_BROWSER.BUILDING:
            {
                startLatency = Date.now();
                if (!process.env.TURBOPACK) {
                    setPendingHotUpdateWebpack();
                }
                console.log('[Fast Refresh] rebuilding');
                break;
            }
        case HMR_ACTIONS_SENT_TO_BROWSER.BUILT:
        case HMR_ACTIONS_SENT_TO_BROWSER.SYNC:
            {
                if (obj.hash) {
                    handleAvailableHash(obj.hash);
                }
                const { errors, warnings } = obj;
                // Is undefined when it's a 'built' event
                if ('versionInfo' in obj) dispatcher.onVersionInfo(obj.versionInfo);
                if ('debug' in obj && obj.debug) dispatcher.onDebugInfo(obj.debug);
                const hasErrors = Boolean(errors && errors.length);
                // Compilation with errors (e.g. syntax error or missing modules).
                if (hasErrors) {
                    sendMessage(JSON.stringify({
                        event: 'client-error',
                        errorCount: errors.length,
                        clientId: __nextDevClientId
                    }));
                    handleErrors(errors);
                    return;
                }
                const hasWarnings = Boolean(warnings && warnings.length);
                if (hasWarnings) {
                    sendMessage(JSON.stringify({
                        event: 'client-warning',
                        warningCount: warnings.length,
                        clientId: __nextDevClientId
                    }));
                    // Print warnings to the console.
                    const formattedMessages = formatWebpackMessages({
                        warnings: warnings,
                        errors: []
                    });
                    for(let i = 0; i < formattedMessages.warnings.length; i++){
                        if (i === 5) {
                            console.warn('There were more warnings in other files.\n' + 'You can find a complete log in the terminal.');
                            break;
                        }
                        console.warn(stripAnsi(formattedMessages.warnings[i]));
                    }
                // No early return here as we need to apply modules in the same way between warnings only and compiles without warnings
                }
                sendMessage(JSON.stringify({
                    event: 'client-success',
                    clientId: __nextDevClientId
                }));
                if (obj.action === HMR_ACTIONS_SENT_TO_BROWSER.BUILT) {
                    // Handle hot updates
                    handleHotUpdate();
                }
                return;
            }
        case HMR_ACTIONS_SENT_TO_BROWSER.TURBOPACK_CONNECTED:
            {
                processTurbopackMessage({
                    type: HMR_ACTIONS_SENT_TO_BROWSER.TURBOPACK_CONNECTED,
                    data: {
                        sessionId: obj.data.sessionId
                    }
                });
                break;
            }
        case HMR_ACTIONS_SENT_TO_BROWSER.TURBOPACK_MESSAGE:
            {
                const updatedModules = extractModulesFromTurbopackMessage(obj.data);
                dispatcher.onBeforeRefresh();
                processTurbopackMessage({
                    type: HMR_ACTIONS_SENT_TO_BROWSER.TURBOPACK_MESSAGE,
                    data: obj.data
                });
                dispatcher.onRefresh();
                if (RuntimeErrorHandler.hadRuntimeError) {
                    console.warn(REACT_REFRESH_FULL_RELOAD_FROM_ERROR);
                    performFullReload(null, sendMessage);
                }
                reportHmrLatency(sendMessage, updatedModules);
                break;
            }
        // TODO-APP: make server component change more granular
        case HMR_ACTIONS_SENT_TO_BROWSER.SERVER_COMPONENT_CHANGES:
            {
                sendMessage(JSON.stringify({
                    event: 'server-component-reload-page',
                    clientId: __nextDevClientId
                }));
                if (RuntimeErrorHandler.hadRuntimeError) {
                    if (reloading) return;
                    reloading = true;
                    return window.location.reload();
                }
                startTransition(()=>{
                    router.hmrRefresh();
                    dispatcher.onRefresh();
                });
                if (process.env.__NEXT_TEST_MODE) {
                    if (self.__NEXT_HMR_CB) {
                        self.__NEXT_HMR_CB();
                        self.__NEXT_HMR_CB = null;
                    }
                }
                return;
            }
        case HMR_ACTIONS_SENT_TO_BROWSER.RELOAD_PAGE:
            {
                sendMessage(JSON.stringify({
                    event: 'client-reload-page',
                    clientId: __nextDevClientId
                }));
                if (reloading) return;
                reloading = true;
                return window.location.reload();
            }
        case HMR_ACTIONS_SENT_TO_BROWSER.ADDED_PAGE:
        case HMR_ACTIONS_SENT_TO_BROWSER.REMOVED_PAGE:
            {
                // TODO-APP: potentially only refresh if the currently viewed page was added/removed.
                return router.hmrRefresh();
            }
        case HMR_ACTIONS_SENT_TO_BROWSER.SERVER_ERROR:
            {
                const { errorJSON } = obj;
                if (errorJSON) {
                    const { message, stack } = JSON.parse(errorJSON);
                    const error = new Error(message);
                    error.stack = stack;
                    handleErrors([
                        error
                    ]);
                }
                return;
            }
        case HMR_ACTIONS_SENT_TO_BROWSER.DEV_PAGES_MANIFEST_UPDATE:
            {
                return;
            }
        default:
            {}
    }
}
export default function HotReload(param) {
    let { assetPrefix, children } = param;
    const [state, dispatch] = useErrorOverlayReducer();
    const dispatcher = useMemo(()=>{
        return {
            onBuildOk () {
                dispatch({
                    type: ACTION_BUILD_OK
                });
            },
            onBuildError (message) {
                dispatch({
                    type: ACTION_BUILD_ERROR,
                    message
                });
            },
            onBeforeRefresh () {
                dispatch({
                    type: ACTION_BEFORE_REFRESH
                });
            },
            onRefresh () {
                dispatch({
                    type: ACTION_REFRESH
                });
            },
            onVersionInfo (versionInfo) {
                dispatch({
                    type: ACTION_VERSION_INFO,
                    versionInfo
                });
            },
            onStaticIndicator (status) {
                dispatch({
                    type: ACTION_STATIC_INDICATOR,
                    staticIndicator: status
                });
            },
            onDebugInfo (debugInfo) {
                dispatch({
                    type: ACTION_DEBUG_INFO,
                    debugInfo
                });
            }
        };
    }, [
        dispatch
    ]);
    const handleOnUnhandledError = useCallback((error)=>{
        const errorDetails = error.details;
        // Component stack is added to the error in use-error-handler in case there was a hydration error
        const componentStackTrace = error._componentStack || (errorDetails == null ? void 0 : errorDetails.componentStack);
        const warning = errorDetails == null ? void 0 : errorDetails.warning;
        const stitchedError = getReactStitchedError(error);
        dispatch({
            type: ACTION_UNHANDLED_ERROR,
            reason: stitchedError,
            frames: parseStack(stitchedError.stack || ''),
            componentStackFrames: typeof componentStackTrace === 'string' ? parseComponentStack(componentStackTrace) : undefined,
            warning
        });
    }, [
        dispatch
    ]);
    const handleOnUnhandledRejection = useCallback((reason)=>{
        const stitchedError = getReactStitchedError(reason);
        dispatch({
            type: ACTION_UNHANDLED_REJECTION,
            reason: stitchedError,
            frames: parseStack(stitchedError.stack || '')
        });
    }, [
        dispatch
    ]);
    useErrorHandler(handleOnUnhandledError, handleOnUnhandledRejection);
    const webSocketRef = useWebsocket(assetPrefix);
    useWebsocketPing(webSocketRef);
    const sendMessage = useSendMessage(webSocketRef);
    const processTurbopackMessage = useTurbopack(sendMessage, (err)=>performFullReload(err, sendMessage));
    const router = useRouter();
    // We don't want access of the pathname for the dev tools to trigger a dynamic
    // access (as the dev overlay will never be present in production).
    const pathname = useUntrackedPathname();
    const appIsrManifestRef = useRef({});
    const pathnameRef = useRef(pathname);
    if (process.env.__NEXT_APP_ISR_INDICATOR) {
        // this conditional is only for dead-code elimination which
        // isn't a runtime conditional only build-time so ignore hooks rule
        // eslint-disable-next-line react-hooks/rules-of-hooks
        useEffect(()=>{
            pathnameRef.current = pathname;
            const appIsrManifest = appIsrManifestRef.current;
            if (appIsrManifest) {
                if (pathname && pathname in appIsrManifest) {
                    var _localStorage;
                    const indicatorHiddenAt = Number((_localStorage = localStorage) == null ? void 0 : _localStorage.getItem('__NEXT_DISMISS_PRERENDER_INDICATOR'));
                    const isHidden = indicatorHiddenAt && !isNaN(indicatorHiddenAt) && Date.now() < indicatorHiddenAt;
                    if (!isHidden) {
                        dispatcher.onStaticIndicator(true);
                    }
                } else {
                    dispatcher.onStaticIndicator(false);
                }
            }
        }, [
            pathname,
            dispatcher
        ]);
    }
    useEffect(()=>{
        const websocket = webSocketRef.current;
        if (!websocket) return;
        const handler = (event)=>{
            try {
                const obj = JSON.parse(event.data);
                processMessage(obj, sendMessage, processTurbopackMessage, router, dispatcher, appIsrManifestRef, pathnameRef);
            } catch (err) {
                var _err_stack;
                console.warn('[HMR] Invalid message: ' + JSON.stringify(event.data) + '\n' + ((_err_stack = err == null ? void 0 : err.stack) != null ? _err_stack : ''));
            }
        };
        websocket.addEventListener('message', handler);
        return ()=>websocket.removeEventListener('message', handler);
    }, [
        sendMessage,
        router,
        webSocketRef,
        dispatcher,
        processTurbopackMessage,
        appIsrManifestRef
    ]);
    return /*#__PURE__*/ _jsx(ReactDevOverlay, {
        state: state,
        dispatcher: dispatcher,
        children: children
    });
}

//# sourceMappingURL=hot-reloader-client.js.map
FILE: node_modules\next\dist\esm\client\components\react-dev-overlay\app\ReactDevOverlay.js
===========================================================================================
import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
import React from 'react';
import { ShadowPortal } from '../internal/components/ShadowPortal';
import { BuildError } from '../internal/container/BuildError';
import { Errors } from '../internal/container/Errors';
import { StaticIndicator } from '../internal/container/StaticIndicator';
import { Base } from '../internal/styles/Base';
import { ComponentStyles } from '../internal/styles/ComponentStyles';
import { CssReset } from '../internal/styles/CssReset';
import { RootLayoutMissingTagsError } from '../internal/container/root-layout-missing-tags-error';
import { RuntimeErrorHandler } from '../internal/helpers/runtime-error-handler';
class ReactDevOverlay extends React.PureComponent {
    static getDerivedStateFromError(error) {
        if (!error.stack) return {
            isReactError: false
        };
        RuntimeErrorHandler.hadRuntimeError = true;
        return {
            isReactError: true
        };
    }
    render() {
        var _state_rootLayoutMissingTags;
        const { state, children, dispatcher } = this.props;
        const { isReactError } = this.state;
        const hasBuildError = state.buildError != null;
        const hasRuntimeErrors = Boolean(state.errors.length);
        const hasStaticIndicator = state.staticIndicator;
        const debugInfo = state.debugInfo;
        return /*#__PURE__*/ _jsxs(_Fragment, {
            children: [
                isReactError ? /*#__PURE__*/ _jsxs("html", {
                    children: [
                        /*#__PURE__*/ _jsx("head", {}),
                        /*#__PURE__*/ _jsx("body", {})
                    ]
                }) : children,
                /*#__PURE__*/ _jsxs(ShadowPortal, {
                    children: [
                        /*#__PURE__*/ _jsx(CssReset, {}),
                        /*#__PURE__*/ _jsx(Base, {}),
                        /*#__PURE__*/ _jsx(ComponentStyles, {}),
                        ((_state_rootLayoutMissingTags = state.rootLayoutMissingTags) == null ? void 0 : _state_rootLayoutMissingTags.length) ? /*#__PURE__*/ _jsx(RootLayoutMissingTagsError, {
                            missingTags: state.rootLayoutMissingTags
                        }) : hasBuildError ? /*#__PURE__*/ _jsx(BuildError, {
                            message: state.buildError,
                            versionInfo: state.versionInfo
                        }) : /*#__PURE__*/ _jsxs(_Fragment, {
                            children: [
                                hasRuntimeErrors ? /*#__PURE__*/ _jsx(Errors, {
                                    isAppDir: true,
                                    initialDisplayState: isReactError ? 'fullscreen' : 'minimized',
                                    errors: state.errors,
                                    versionInfo: state.versionInfo,
                                    hasStaticIndicator: hasStaticIndicator,
                                    debugInfo: debugInfo
                                }) : null,
                                hasStaticIndicator && /*#__PURE__*/ _jsx(StaticIndicator, {
                                    dispatcher: dispatcher
                                })
                            ]
                        })
                    ]
                })
            ]
        });
    }
    constructor(...args){
        super(...args);
        this.state = {
            isReactError: false
        };
    }
}
export { ReactDevOverlay as default };

//# sourceMappingURL=ReactDevOverlay.js.mapRepository Structure for app:
===================

├── app-bundle-path-normalizer.js
├── app-filename-normalizer.js
├── app-page-normalizer.js
├── app-pathname-normalizer.js
├── index.js


File Contents:
=============


FILE: node_modules\next\dist\esm\server\normalizers\built\app\app-bundle-path-normalizer.js
===========================================================================================
import { Normalizers } from '../../normalizers';
import { PrefixingNormalizer } from '../../prefixing-normalizer';
import { normalizePagePath } from '../../../../shared/lib/page-path/normalize-page-path';
export class AppBundlePathNormalizer extends PrefixingNormalizer {
    constructor(){
        super('app');
    }
    normalize(page) {
        return super.normalize(normalizePagePath(page));
    }
}
export class DevAppBundlePathNormalizer extends Normalizers {
    constructor(pageNormalizer){
        super([
            // This should normalize the filename to a page.
            pageNormalizer,
            // Normalize the app page to a pathname.
            new AppBundlePathNormalizer()
        ]);
    }
    normalize(filename) {
        return super.normalize(filename);
    }
}

//# sourceMappingURL=app-bundle-path-normalizer.js.map
FILE: node_modules\next\dist\esm\server\normalizers\built\app\app-filename-normalizer.js
========================================================================================
import { SERVER_DIRECTORY } from '../../../../shared/lib/constants';
import { PrefixingNormalizer } from '../../prefixing-normalizer';
export class AppFilenameNormalizer extends PrefixingNormalizer {
    constructor(distDir){
        super(distDir, SERVER_DIRECTORY);
    }
    normalize(manifestFilename) {
        return super.normalize(manifestFilename);
    }
}

//# sourceMappingURL=app-filename-normalizer.js.map
FILE: node_modules\next\dist\esm\server\normalizers\built\app\app-page-normalizer.js
====================================================================================
import { PAGE_TYPES } from '../../../../lib/page-types';
import { AbsoluteFilenameNormalizer } from '../../absolute-filename-normalizer';
/**
 * DevAppPageNormalizer is a normalizer that is used to normalize a pathname
 * to a page in the `app` directory.
 */ export class DevAppPageNormalizer extends AbsoluteFilenameNormalizer {
    constructor(appDir, extensions){
        super(appDir, extensions, PAGE_TYPES.APP);
    }
}

//# sourceMappingURL=app-page-normalizer.js.map
FILE: node_modules\next\dist\esm\server\normalizers\built\app\app-pathname-normalizer.js
========================================================================================
import { normalizeAppPath } from '../../../../shared/lib/router/utils/app-paths';
import { Normalizers } from '../../normalizers';
import { wrapNormalizerFn } from '../../wrap-normalizer-fn';
import { UnderscoreNormalizer } from '../../underscore-normalizer';
export class AppPathnameNormalizer extends Normalizers {
    constructor(){
        super([
            // The pathname to match should have the trailing `/page` and other route
            // group information stripped from it.
            wrapNormalizerFn(normalizeAppPath),
            // The page should have the `%5F` characters replaced with `_` characters.
            new UnderscoreNormalizer()
        ]);
    }
    normalize(page) {
        return super.normalize(page);
    }
}
export class DevAppPathnameNormalizer extends Normalizers {
    constructor(pageNormalizer){
        super([
            // This should normalize the filename to a page.
            pageNormalizer,
            // Normalize the app page to a pathname.
            new AppPathnameNormalizer()
        ]);
    }
    normalize(filename) {
        return super.normalize(filename);
    }
}

//# sourceMappingURL=app-pathname-normalizer.js.map
FILE: node_modules\next\dist\esm\server\normalizers\built\app\index.js
======================================================================
import { AppBundlePathNormalizer, DevAppBundlePathNormalizer } from './app-bundle-path-normalizer';
import { AppFilenameNormalizer } from './app-filename-normalizer';
import { DevAppPageNormalizer } from './app-page-normalizer';
import { AppPathnameNormalizer, DevAppPathnameNormalizer } from './app-pathname-normalizer';
export class AppNormalizers {
    constructor(distDir){
        this.filename = new AppFilenameNormalizer(distDir);
        this.pathname = new AppPathnameNormalizer();
        this.bundlePath = new AppBundlePathNormalizer();
    }
}
export class DevAppNormalizers {
    constructor(appDir, extensions){
        this.page = new DevAppPageNormalizer(appDir, extensions);
        this.pathname = new DevAppPathnameNormalizer(this.page);
        this.bundlePath = new DevAppBundlePathNormalizer(this.page);
    }
}

//# sourceMappingURL=index.js.mapRepository Structure for app:
===================

├── app-bundle-path-normalizer.js
├── app-filename-normalizer.js
├── app-page-normalizer.js
├── app-pathname-normalizer.js
├── index.js


File Contents:
=============


FILE: node_modules\next\dist\server\normalizers\built\app\app-bundle-path-normalizer.js
=======================================================================================
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    AppBundlePathNormalizer: null,
    DevAppBundlePathNormalizer: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    AppBundlePathNormalizer: function() {
        return AppBundlePathNormalizer;
    },
    DevAppBundlePathNormalizer: function() {
        return DevAppBundlePathNormalizer;
    }
});
const _normalizers = require("../../normalizers");
const _prefixingnormalizer = require("../../prefixing-normalizer");
const _normalizepagepath = require("../../../../shared/lib/page-path/normalize-page-path");
class AppBundlePathNormalizer extends _prefixingnormalizer.PrefixingNormalizer {
    constructor(){
        super('app');
    }
    normalize(page) {
        return super.normalize((0, _normalizepagepath.normalizePagePath)(page));
    }
}
class DevAppBundlePathNormalizer extends _normalizers.Normalizers {
    constructor(pageNormalizer){
        super([
            // This should normalize the filename to a page.
            pageNormalizer,
            // Normalize the app page to a pathname.
            new AppBundlePathNormalizer()
        ]);
    }
    normalize(filename) {
        return super.normalize(filename);
    }
}

//# sourceMappingURL=app-bundle-path-normalizer.js.map
FILE: node_modules\next\dist\server\normalizers\built\app\app-filename-normalizer.js
====================================================================================
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "AppFilenameNormalizer", {
    enumerable: true,
    get: function() {
        return AppFilenameNormalizer;
    }
});
const _constants = require("../../../../shared/lib/constants");
const _prefixingnormalizer = require("../../prefixing-normalizer");
class AppFilenameNormalizer extends _prefixingnormalizer.PrefixingNormalizer {
    constructor(distDir){
        super(distDir, _constants.SERVER_DIRECTORY);
    }
    normalize(manifestFilename) {
        return super.normalize(manifestFilename);
    }
}

//# sourceMappingURL=app-filename-normalizer.js.map
FILE: node_modules\next\dist\server\normalizers\built\app\app-page-normalizer.js
================================================================================
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "DevAppPageNormalizer", {
    enumerable: true,
    get: function() {
        return DevAppPageNormalizer;
    }
});
const _pagetypes = require("../../../../lib/page-types");
const _absolutefilenamenormalizer = require("../../absolute-filename-normalizer");
class DevAppPageNormalizer extends _absolutefilenamenormalizer.AbsoluteFilenameNormalizer {
    constructor(appDir, extensions){
        super(appDir, extensions, _pagetypes.PAGE_TYPES.APP);
    }
}

//# sourceMappingURL=app-page-normalizer.js.map
FILE: node_modules\next\dist\server\normalizers\built\app\app-pathname-normalizer.js
====================================================================================
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    AppPathnameNormalizer: null,
    DevAppPathnameNormalizer: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    AppPathnameNormalizer: function() {
        return AppPathnameNormalizer;
    },
    DevAppPathnameNormalizer: function() {
        return DevAppPathnameNormalizer;
    }
});
const _apppaths = require("../../../../shared/lib/router/utils/app-paths");
const _normalizers = require("../../normalizers");
const _wrapnormalizerfn = require("../../wrap-normalizer-fn");
const _underscorenormalizer = require("../../underscore-normalizer");
class AppPathnameNormalizer extends _normalizers.Normalizers {
    constructor(){
        super([
            // The pathname to match should have the trailing `/page` and other route
            // group information stripped from it.
            (0, _wrapnormalizerfn.wrapNormalizerFn)(_apppaths.normalizeAppPath),
            // The page should have the `%5F` characters replaced with `_` characters.
            new _underscorenormalizer.UnderscoreNormalizer()
        ]);
    }
    normalize(page) {
        return super.normalize(page);
    }
}
class DevAppPathnameNormalizer extends _normalizers.Normalizers {
    constructor(pageNormalizer){
        super([
            // This should normalize the filename to a page.
            pageNormalizer,
            // Normalize the app page to a pathname.
            new AppPathnameNormalizer()
        ]);
    }
    normalize(filename) {
        return super.normalize(filename);
    }
}

//# sourceMappingURL=app-pathname-normalizer.js.map
FILE: node_modules\next\dist\server\normalizers\built\app\index.js
==================================================================
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    AppNormalizers: null,
    DevAppNormalizers: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    AppNormalizers: function() {
        return AppNormalizers;
    },
    DevAppNormalizers: function() {
        return DevAppNormalizers;
    }
});
const _appbundlepathnormalizer = require("./app-bundle-path-normalizer");
const _appfilenamenormalizer = require("./app-filename-normalizer");
const _apppagenormalizer = require("./app-page-normalizer");
const _apppathnamenormalizer = require("./app-pathname-normalizer");
class AppNormalizers {
    constructor(distDir){
        this.filename = new _appfilenamenormalizer.AppFilenameNormalizer(distDir);
        this.pathname = new _apppathnamenormalizer.AppPathnameNormalizer();
        this.bundlePath = new _appbundlepathnormalizer.AppBundlePathNormalizer();
    }
}
class DevAppNormalizers {
    constructor(appDir, extensions){
        this.page = new _apppagenormalizer.DevAppPageNormalizer(appDir, extensions);
        this.pathname = new _apppathnamenormalizer.DevAppPathnameNormalizer(this.page);
        this.bundlePath = new _appbundlepathnormalizer.DevAppBundlePathNormalizer(this.page);
    }
}

//# sourceMappingURL=index.js.map